<application>
  <component name="AppStorage">
    <histories>
      <item value="symbol SSL_set_alpn_protos, version libssl.so.10 not defined in file libssl.so.10 with link time reference " />
      <item value="squid: relocation error: squid: symbol SSL_set_alpn_protos, version libssl.so.10 not defined in file libssl.so.10 with link time reference " />
      <item value="Unregistered Authentication Agent for unix-process:26260:3587956604 (system bus name :1.427291, object path /org/freedesktop/PolicyKit1/Authenticatio" />
      <item value="Job for squid.service failed because the control process exited with error code. See &quot;systemctl status squid.service&quot; and &quot;journalctl -xe&quot; for details. " />
      <item value="TypeError: argument of type 'DataError' is not iterable" />
      <item value="directory" />
      <item value="SyntaxError: name 'CLIENT' is used prior to global declaration" />
      <item value="SyntaxError: name 'CLIENT' is used prior to global declaratio" />
      <item value="UnboundLocalError: local variable 'CLIENT' referenced before assignment" />
      <item value="fdfs_client.exceptions.DataError: Error: 2, No such file or directory" />
      <item value="清理" />
      <item value="Error: Could not open client transport with JDBC Uri: jdbc:hive2://192.168.129.10:10000: Failed to open new session: java.lang.RuntimeException: org.apache.hadoop.ipc.RemoteException(org.apache.hadoop.security.authorize.AuthorizationException): User: root is not allowed to impersonate root (state=08S01,code=0) " />
      <item value="Use with auth='KERBEROS' only" />
      <item value="A dictionary of Hive settings (functionally same as the `set` command)" />
      <item value="The value of hive.server2.authentication used by HiveServer2. Defaults to ``NONE``." />
      <item value="ValueError: Password should be set if and only if in LDAP or CUSTOM mode; Remove password or use one of those modes" />
      <item value="The standard calling form is to send the URL as the first positional argument, usually a string that indicates database dialect and connection arguments:: engine = create_engine(&quot;postgresql://scott:tiger@localhost/test&quot;) Additional keyword arguments may then follow it which establish various options on the resulting :class:`.Engine` and its underlying :class:`.Dialect` and :class:`.Pool` constructs:: engine = create_engine(&quot;mysql://scott:tiger@hostname/dbname&quot;, encoding='latin1', echo=True) The string form of the URL is ``dialect[+driver]://user:password@host/dbname[?key=value..]``, where ``dialect`` is a database name such as ``mysql``, ``oracle``, ``postgresql``, etc., and ``driver`` the name of a DBAPI, such as ``psycopg2``, ``pyodbc``, ``cx_oracle``, etc. Alternatively, the URL can be an instance of :class:`~sqlalchemy.engine.url.URL`. ``**kwargs`` takes a wide variety of options which are routed towards their appropriate components. Arguments may be specific to the :class:`.Engine`, the underlying :class:`.Dialect`, as well as the :class:`.Pool`. Specific dialects also accept keyword arguments that are unique to that dialect. Here, we describe the parameters that are common to most :func:`.create_engine()` usage. Once established, the newly resulting :class:`.Engine` will request a connection from the underlying :class:`.Pool` once :meth:`.Engine.connect` is called, or a method which depends on it such as :meth:`.Engine.execute` is invoked. The :class:`.Pool` in turn will establish the first actual DBAPI connection when this request is received. The :func:`.create_engine` call itself does **not** establish any actual DBAPI connections directly. .. seealso:: :doc:`/core/engines` :doc:`/dialects/index` :ref:`connections_toplevel` :param case_sensitive=True: if False, result column names will match in a case-insensitive fashion, that is, ``row['SomeColumn']``. :param connect_args: a dictionary of options which will be passed directly to the DBAPI's ``connect()`` method as additional keyword arguments. See the example at :ref:`custom_dbapi_args`. :param convert_unicode=False: if set to True, causes all :class:`.String` datatypes to act as though the :paramref:`.String.convert_unicode` flag has been set to ``True``, regardless of a setting of ``False`` on an individual :class:`.String` type. This has the effect of causing all :class:`.String` -based columns to accommodate Python Unicode objects directly as though the datatype were the :class:`.Unicode` type. .. deprecated:: 1.3 The :paramref:`.create_engine.convert_unicode` parameter is deprecated and will be removed in a future release. All modern DBAPIs now support Python Unicode directly and this parameter is unnecessary. :param creator: a callable which returns a DBAPI connection. This creation function will be passed to the underlying connection pool and will be used to create all new database connections. Usage of this function causes connection parameters specified in the URL argument to be bypassed. :param echo=False: if True, the Engine will log all statements as well as a ``repr()`` of their parameter lists to the default log handler, which defaults to ``sys.stdout`` for output. If set to the string ``&quot;debug&quot;``, result rows will be printed to the standard output as well. The ``echo`` attribute of ``Engine`` can be modified at any time to turn logging on and off; direct control of logging is also available using the standard Python ``logging`` module. .. seealso:: :ref:`dbengine_logging` - further detail on how to configure logging. :param echo_pool=False: if True, the connection pool will log informational output such as when connections are invalidated as well as when connections are recycled to the default log handler, which defaults to ``sys.stdout`` for output. If set to the string ``&quot;debug&quot;``, the logging will include pool checkouts and checkins. Direct control of logging is also available using the standard Python ``logging`` module. .. seealso:: :ref:`dbengine_logging` - further detail on how to configure logging. :param empty_in_strategy: The SQL compilation strategy to use when rendering an IN or NOT IN expression for :meth:`.ColumnOperators.in_` where the right-hand side is an empty set. This is a string value that may be one of ``static``, ``dynamic``, or ``dynamic_warn``. The ``static`` strategy is the default, and an IN comparison to an empty set will generate a simple false expression &quot;1 != 1&quot;. The ``dynamic`` strategy behaves like that of SQLAlchemy 1.1 and earlier, emitting a false expression of the form &quot;expr != expr&quot;, which has the effect of evaluting to NULL in the case of a null expression. ``dynamic_warn`` is the same as ``dynamic``, however also emits a warning when an empty set is encountered; this because the &quot;dynamic&quot; comparison is typically poorly performing on most databases. .. versionadded:: 1.2 Added the ``empty_in_strategy`` setting and additionally defaulted the behavior for empty-set IN comparisons to a static boolean expression. :param encoding: Defaults to ``utf-8``. This is the string encoding used by SQLAlchemy for string encode/decode operations which occur within SQLAlchemy, **outside of the DBAPI.** Most modern DBAPIs feature some degree of direct support for Python ``unicode`` objects, what you see in Python 2 as a string of the form ``u'some string'``. For those scenarios where the DBAPI is detected as not supporting a Python ``unicode`` object, this encoding is used to determine the source/destination encoding. It is **not used** for those cases where the DBAPI handles unicode directly. To properly configure a system to accommodate Python ``unicode`` objects, the DBAPI should be configured to handle unicode to the greatest degree as is appropriate - see the notes on unicode pertaining to the specific target database in use at :ref:`dialect_toplevel`. Areas where string encoding may need to be accommodated outside of the DBAPI include zero or more of: * the values passed to bound parameters, corresponding to the :class:`.Unicode` type or the :class:`.String` type when ``convert_unicode`` is ``True``; * the values returned in result set columns corresponding to the :class:`.Unicode` type or the :class:`.String` type when ``convert_unicode`` is ``True``; * the string SQL statement passed to the DBAPI's ``cursor.execute()`` method; * the string names of the keys in the bound parameter dictionary passed to the DBAPI's ``cursor.execute()`` as well as ``cursor.setinputsizes()`` methods; * the string column names retrieved from the DBAPI's ``cursor.description`` attribute. When using Python 3, the DBAPI is required to support *all* of the above values as Python ``unicode`` objects, which in Python 3 are just known as ``str``. In Python 2, the DBAPI does not specify unicode behavior at all, so SQLAlchemy must make decisions for each of the above values on a per-DBAPI basis - implementations are completely inconsistent in their behavior. :param execution_options: Dictionary execution options which will be applied to all connections. See :meth:`~sqlalchemy.engine.Connection.execution_options` :param implicit_returning=True: When ``True``, a RETURNING- compatible construct, if available, will be used to fetch newly generated primary key values when a single row INSERT statement is emitted with no existing returning() clause. This applies to those backends which support RETURNING or a compatible construct, including PostgreSQL, Firebird, Oracle, Microsoft SQL Server. Set this to ``False`` to disable the automatic usage of RETURNING. :param isolation_level: this string parameter is interpreted by various dialects in order to affect the transaction isolation level of the database connection. The parameter essentially accepts some subset of these string arguments: ``&quot;SERIALIZABLE&quot;``, ``&quot;REPEATABLE_READ&quot;``, ``&quot;READ_COMMITTED&quot;``, ``&quot;READ_UNCOMMITTED&quot;`` and ``&quot;AUTOCOMMIT&quot;``. Behavior here varies per backend, and individual dialects should be consulted directly. Note that the isolation level can also be set on a per-:class:`.Connection` basis as well, using the :paramref:`.Connection.execution_options.isolation_level` feature. .. seealso:: :attr:`.Connection.default_isolation_level` - view default level :paramref:`.Connection.execution_options.isolation_level` - set per :class:`.Connection` isolation level :ref:`SQLite Transaction Isolation &lt;sqlite_isolation_level&gt;` :ref:`PostgreSQL Transaction Isolation &lt;postgresql_isolation_level&gt;` :ref:`MySQL Transaction Isolation &lt;mysql_isolation_level&gt;` :ref:`session_transaction_isolation` - for the ORM :param label_length=None: optional integer value which limits the size of dynamically generated column labels to that many characters. If less than 6, labels are generated as &quot;_(counter)&quot;. If ``None``, the value of ``dialect.max_identifier_length`` is used instead. :param listeners: A list of one or more :class:`~sqlalchemy.interfaces.PoolListener` objects which will receive connection pool events. :param logging_name: String identifier which will be used within the &quot;name&quot; field of logging records generated within the &quot;sqlalchemy.engine&quot; logger. Defaults to a hexstring of the object's id. :param max_overflow=10: the number of connections to allow in connection pool &quot;overflow&quot;, that is connections that can be opened above and beyond the pool_size setting, which defaults to five. this is only used with :class:`~sqlalchemy.pool.QueuePool`. :param module=None: reference to a Python module object (the module itself, not its string name). Specifies an alternate DBAPI module to be used by the engine's dialect. Each sub-dialect references a specific DBAPI which will be imported before first connect. This parameter causes the import to be bypassed, and the given module to be used instead. Can be used for testing of DBAPIs as well as to inject &quot;mock&quot; DBAPI implementations into the :class:`.Engine`. :param paramstyle=None: The `paramstyle &lt;http://legacy.python.org/dev/peps/pep-0249/#paramstyle&gt;`_ to use when rendering bound parameters. This style defaults to the one recommended by the DBAPI itself, which is retrieved from the ``.paramstyle`` attribute of the DBAPI. However, most DBAPIs accept more than one paramstyle, and in particular it may be desirable to change a &quot;named&quot; paramstyle into a &quot;positional&quot; one, or vice versa. When this attribute is passed, it should be one of the values ``&quot;qmark&quot;``, ``&quot;numeric&quot;``, ``&quot;named&quot;``, ``&quot;format&quot;`` or ``&quot;pyformat&quot;``, and should correspond to a parameter style known to be supported by the DBAPI in use. :param pool=None: an already-constructed instance of :class:`~sqlalchemy.pool.Pool`, such as a :class:`~sqlalchemy.pool.QueuePool` instance. If non-None, this pool will be used directly as the underlying connection pool for the engine, bypassing whatever connection parameters are present in the URL argument. For information on constructing connection pools manually, see :ref:`pooling_toplevel`. :param poolclass=None: a :class:`~sqlalchemy.pool.Pool` subclass, which will be used to create a connection pool instance using the connection parameters given in the URL. Note this differs from ``pool`` in that you don't actually instantiate the pool in this case, you just indicate what type of pool to be used. :param pool_logging_name: String identifier which will be used within the &quot;name&quot; field of logging records generated within the &quot;sqlalchemy.pool&quot; logger. Defaults to a hexstring of the object's id. :param pool_pre_ping: boolean, if True will enable the connection pool &quot;pre-ping&quot; feature that tests connections for liveness upon each checkout. .. versionadded:: 1.2 .. seealso:: :ref:`pool_disconnects_pessimistic` :param pool_size=5: the number of connections to keep open inside the connection pool. This used with :class:`~sqlalchemy.pool.QueuePool` as well as :class:`~sqlalchemy.pool.SingletonThreadPool`. With :class:`~sqlalchemy.pool.QueuePool`, a ``pool_size`` setting of 0 indicates no limit; to disable pooling, set ``poolclass`` to :class:`~sqlalchemy.pool.NullPool` instead. :param pool_recycle=-1: this setting causes the pool to recycle connections after the given number of seconds has passed. It defaults to -1, or no timeout. For example, setting to 3600 means connections will be recycled after one hour. Note that MySQL in particular will disconnect automatically if no activity is detected on a connection for eight hours (although this is configurable with the MySQLDB connection itself and the server configuration as well). .. seealso:: :ref:`pool_setting_recycle` :param pool_reset_on_return='rollback': set the :paramref:`.Pool.reset_on_return` parameter of the underlying :class:`.Pool` object, which can be set to the values ``&quot;rollback&quot;``, ``&quot;commit&quot;``, or ``None``. .. seealso:: :paramref:`.Pool.reset_on_return` :param pool_timeout=30: number of seconds to wait before giving up on getting a connection from the pool. This is only used with :class:`~sqlalchemy.pool.QueuePool`. :param pool_use_lifo=False: use LIFO (last-in-first-out) when retrieving connections from :class:`.QueuePool` instead of FIFO (first-in-first-out). Using LIFO, a server-side timeout scheme can reduce the number of connections used during non- peak periods of use. When planning for server-side timeouts, ensure that a recycle or pre-ping strategy is in use to gracefully handle stale connections. .. versionadded:: 1.3 .. seealso:: :ref:`pool_use_lifo` :ref:`pool_disconnects` :param plugins: string list of plugin names to load. See :class:`.CreateEnginePlugin` for background. .. versionadded:: 1.2.3 :param strategy='plain': selects alternate engine implementations. Currently available are: * the ``threadlocal`` strategy, which is described in :ref:`threadlocal_strategy`; * the ``mock`` strategy, which dispatches all statement execution to a function passed as the argument ``executor``. See `example in the FAQ &lt;http://docs.sqlalchemy.org/en/latest/faq/metadata_schema.html#how-can-i-get-the-create-table-drop-table-output-as-a-string&gt;`_. :param executor=None: a function taking arguments ``(sql, *multiparams, **params)``, to which the ``mock`` strategy will dispatch all statement execution. Used only by ``strategy='m" />
      <item value="Could not start SASL: b'Error in sasl_client_start (-4) SASL(-4): no mechanism available: Unable to find a callback: 2'" />
      <item value="thrift.transport.TTransport.TTransportException: TSocket read 0 bytes" />
      <item value="thrift.transport.TTransport.TTransportException: Could not start SASL: b'Error in sasl_client_start (-4) SASL(-4): no mechanism available: Unable to find a callback: 2'" />
      <item value="脚本" />
      <item value="rate" />
      <item value="Return whether the object has an attribute with the given name. This is done by calling getattr(obj, name) and catching AttributeError." />
      <item value="Return whether an object is an instance of a class or of a subclass thereof. A tuple, as in ``isinstance(x, (A, B, ...))``, may be given as the target to check against. This is equivalent to ``isinstance(x, A) or isinstance(x, B) or ...`` etc." />
      <item value="ERROR: spyder 3.3.2 has requirement pyqt5&lt;5.10; python_version &gt;= &quot;3&quot;, but you'll have pyqt5 5.10.1 which is incompatible. ERROR: spyder 3.3.2 has requirement spyder-kernels&lt;1.0, but you'll have spyder-kernels 1.3.2 which is incompatible. " />
      <item value="=&gt; WARNING: A newer version of conda exists. &lt;== current version: 4.6.8 latest version: 4.6.14 Please update conda by running $ conda update -n base -c defaults conda" />
      <item value="RemoveError: 'setuptools' is a dependency of conda and cannot be removed from" />
      <item value="tendent" />
      <item value="shown" />
      <item value="Provisional " />
      <item value="No space left on device" />
      <item value="provider" />
      <item value="{address space usage: 530145280 bytes/505MB} {rss usage: 53854208 bytes/51MB} [pid: 28769|app: 0|req: 7/8] 10.10.10.43 () {38 vars in 650 bytes} [Mon May 27 13:42:29 2019] GET /article?url=https://weibo.com/6491728198/Hw7bg3oF2?refer_flag=1001030103_&amp;type=comment =&gt; generated 32 bytes in 1471 msecs (HTTP/1.1 200) 3 headers in 111 bytes (1 switches on core 1) " />
      <item value="org.apache.hadoop.hbase.regionserver.NoSuchColumnFamilyException: Column family wb does not exist in region WEIBO_USER_TABLE,6450585192,1558500977607.87aae1175568fcec14731ee8a689ba3d. in table 'WEIBO_USER_TABLE', {NAME =&gt; 'wa', BLOOMFILTER =&gt; 'ROW', VERSIONS =&gt; '2', IN_MEMORY =&gt; 'false', KEEP_DELETED_CELLS =&gt; 'FALSE', DATA_BLOCK_ENCODING =&gt; 'NONE', TTL =&gt; 'FOREVER', COMPRESSION =&gt; 'NONE', MIN_VERSIONS =&gt; '0', BLOCKCACHE =&gt; 'true', BLOCKSIZE =&gt; '65536', REPLICATION_SCOPE =&gt; '1'}" />
      <item value="TypeError: not all arguments converted during string formatting" />
      <item value="Arguments" />
      <item value="Message" />
      <item value="interchangeable" />
      <item value="通用" />
      <item value="通用的" />
      <item value="ait for child process to terminate.  Returns returncode " />
      <item value="ait for child process to terminate.  Returns returncode             attribute" />
      <item value="REPEATED" />
      <item value="field" />
      <item value="record" />
      <item value="REPEATED TITLE DETECTION" />
      <item value="SITE RECORD" />
      <item value="weiwb" />
      <item value="sign" />
      <item value="ModuleNotFoundError: No module named '_bz2'" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="231" />
        <entry key="ENGLISH" value="231" />
        <entry key="GERMAN" value="1" />
        <entry key="FRENCH" value="2" />
        <entry key="HAITIAN_CREOLE" value="3" />
        <entry key="ROMANIAN" value="2" />
        <entry key="SWEDISH" value="4" />
        <entry key="TELUGU" value="1" />
        <entry key="TURKISH" value="1" />
        <entry key="SPANISH" value="1" />
        <entry key="ITALIAN" value="1" />
        <entry key="HINDI" value="2" />
      </map>
    </option>
  </component>
</application>